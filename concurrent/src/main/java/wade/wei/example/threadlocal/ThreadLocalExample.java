package wade.wei.example.threadlocal;

/**
 * @author Administrator
 * 将不能被修改的类对象，设置为不可变对象，来让对象在多个线程间是线程安全的。
 * 归根到底，其实是躲避开了并发的问题。除了不可变对象，还存在一个方法 就是线程封闭
 *
 * 线程封闭
 * ​   把对象封装到一个线程里，只有这一个线程能看到该对象，那么就算这个对象不是线程安全的，也不会出现任何线程安全的问题，因为它只能在一个线程中被访问，如何实现线程封闭：
 *
 *  Ad-hoc 线程封闭：程序控制实现，非常脆弱、最糟糕，忽略
 *  堆栈封闭：简单的说就是局部变量，无并发问题。多个线程访问同一个方法的时候，方法中的局部变量都会被拷贝一份到线程栈中，
 *            方法的局部变量是不被多个线程共享的，因此不会出现线程安全问题，能用局部变量就不推荐使用全局变量，全局变量容易引起并发问题，注意，全局的变量而不是全局的常量。
 *  ThreadLocal 线程封闭：特别好的封闭方法
 *
 *  <b>总结：ThreadLocal的作用是提供线程内部的局部变量，这种变量只存在线程的生命周期。</b>
 *
 *  应用场景
 * ​   ThreadLocal中存放的变量只在线程的生命周期内起作用，应用场景只要有两个方面：
 *
 * 1. 提供一个线程内公共变量（比如本次请求的用户信息、实体参数），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度
 * 2. 为线程提供一个私有的变量副本，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
 *
 */
public class ThreadLocalExample {

}
